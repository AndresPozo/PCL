/*
   Image Plate Solver

   Plate solving of astronomical images.

   Copyright (C) 2012-2013, Andres del Pozo
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, this
      list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
   Changelog:

   3.1:   * Added parameter "Align Algorithm"

   3.0.1: * Fixed the validation of the value of the resolution

   3.0:   * Use of a distortion template
          * New "Only optimize" option

   2.0.1: * Removed all the usages of "with" in order to run the script in strict mode

   2.0:   * Support for higher degree polynomials
          * Optimization by least squares lineal regression
          * Catalogs TYCHO-2 and BrightStars
          * Advanced parameters collapsible panel

   1.7.4: * Improved error management

   1.7.3: * Fixed layout problems in PixInsight 1.8RC4
          * Another fix that increases the precision of the coordinates
          * Changed all icons to standard PI Core 1.8 resources
          * Button icons also shown on Mac OS X
          * Fixed copyright years (2012-2013)

   1.7.2: * Fixed the selection of catalogs
          * Better precision of the coordinates

   1.7.1: * Temporal fix for bug because StarAlignment uses a non-standard origin of coordinates

   1.7:   * Validated for PixInsight 1.8

   1.6:   * Refactored to allow its use in other scripts.

   1.51:  * 2012 Apr 19 - Released as an official update.
          * Removed all instances of the 'with' JavaScript statement.
          * Fixed some text messsages.

   1.5:   * Search online of initial coordinates by name or identifier

   1.4:   * Adds support for saving the parameters as an icon.
          * It can be applied to an image container.
          * When Reset is pressed now it is not necessary to reopen the script
          * Fixed problem with incomplete values in DATE-OBS
          * The algorithm stops when the number of iterations is reached or the
            delta between iterations is less than 0.1 pixels
          * Code clean up

   1.3:   * Support for online catalogs (PPMXL and UCAC3)
          * ransacTolerance reverted to its default value
          * Added control for the sensitivity of the star detector
          * Reset button

   1.2:   * Modified for sharing code with Annotation Script
          * matcherTolerance reverted to its default value
          * Decreased to 0.05" the condition of convergence

   1.1:   * Adapted to use CSV star lists with newer versions of the
            StarGenerator and StarAlignment processes.
          * General code cleanup.

   1.0:   * Writes the WCS coordinates in the file
          * More accurate algorithm

   0.2:   * Much better precision and speed.
          * It uses the formulas of the gnomonic projection.

   0.1.1: * Fixed error in databasePath

   0.1:   * Initial test version.
*/

/* Coordinate spaces:
   Image Pixels (I): Pixels of the image in PixInsight.
         Increases from left to right and top to bottom
         The center of the top left pixel has the coordinates (0.5, 0.5)
   Star Field (S): Pixels of the reference image generated by StarGenerator.
         The axis are the same as I.
   Gnomonic projected space (G): Projected space result of projecting the celestial
         coordinates with a Gnomonic projection.
         It coincides with the World Intermediate Coordinates of WCS.
         Increases from right to left and bottom to top
         The center of the image has coordinates (0,0).
   FITS WCS pixels (F): Pixels of the image using WCS conventions
         http://fits.gsfc.nasa.gov/fits_wcs.html "Representations of World Coordinates in FITS" (Sections 2.1.4 and 5.1)
         http://fits.gsfc.nasa.gov/fits_wcs.html "Representations of celestial coordinates in FITS" (Section 5, page 1085)
         Increases from left to right and bottom to top
         The center of the bottom left pixel has the coordinates (1,1)
*/

#feature-id    Image Analysis > ImageSolver

#feature-info  A script for plate-solving astronomical images.<br/>\
               <br/>\
               Copyright &copy; 2012-2013 Andr&eacute;s del Pozo

#include <pjsr/DataType.jsh>
#include <pjsr/Sizer.jsh>
#include <pjsr/FrameStyle.jsh>
#include <pjsr/TextAlign.jsh>
#include <pjsr/StdButton.jsh>
#include <pjsr/StdIcon.jsh>
#include <pjsr/StdCursor.jsh>
#include <pjsr/UndoFlag.jsh>
#include <pjsr/ColorSpace.jsh>
#include <pjsr/NumericControl.jsh>

#ifndef __PJSR_SectionBar_jsh
#include <pjsr/SectionBar.jsh>
#endif

#define SOLVERVERSION "3.1"

#ifndef USE_SOLVER_LIBRARY
#define TITLE "Image Solver"
#define SETTINGS_MODULE "SOLVER"
//#define DEBUG

#include "WCSmetadata.jsh"
#include "AstronomicalCatalogs.jsh"
#include "SearchCoordinatesDialog.js"

#define STAR_CSV_FILE   File.systemTempDirectory + "/stars.csv"
#endif

#define SETTINGS_MODULE_SCRIPT "SOLVER"

// -------------------------------------
// ENUMERATION AlignMode

function AlignAlgorithm()
{
}
AlignAlgorithm.prototype.Triangles = 0;
AlignAlgorithm.prototype.Polygons = 1;

// ******************************************************************
// SolverConfiguration: Configuration information of Solver engine
// ******************************************************************
function SolverConfiguration(module)
{
   this.__base__ = ObjectWithSettings;
   this.__base__(
      module,
      "solver",
      new Array(
         ["magnitude", DataType_Float],
         ["maxIterations", DataType_UInt8],
         ["polyDegree", DataType_UInt8],
         ["databasePath", DataType_UCString],
         ["updateKeywords", DataType_Boolean],
         ["writeWCS", DataType_Boolean],
         ["generateErrorImg", DataType_Boolean],
         ["sensitivity", DataType_Double],
         ["catalogMode", DataType_UInt8],
         ["vizierServer", DataType_UCString],
         ["showStars", DataType_Boolean],
         ["showDistortion", DataType_Boolean],
         ["catalog", DataType_UCString],
         ["distortionTemplate", DataType_UCString],
         ["onlyOptimize", DataType_Boolean],
         ["alignAlgorithm", DataType_UInt8]
      )
   );

   this.availableCatalogs = [new UCAC3Catalog(),new PPMXLCatalog(),new TychoCatalog(),new HR_Catalog()];
   this.catalogMode = 1;
   this.vizierServer = "http://vizier.u-strasbg.fr/";
   this.magnitude = 12;
   this.maxIterations = 10;
   this.sensitivity = -1;
   this.writeWCS = true;
   this.updateKeywords = true;
   this.generateErrorImg = false;
   this.templateSizeFactor = 1.5;
   this.showStars = false;
   this.catalog = "PPMXL";
   this.polyDegree = 1;
   this.showDistortion=false;
   this.onlyOptimize = false;
   this.distortionTemplate = null;
   this.alignAlgorithm = AlignAlgorithm.prototype.Triangles;

   this.ResetSettings = function()
   {
      Settings.remove( SETTINGS_MODULE );
   }
}

SolverConfiguration.prototype = new ObjectWithSettings;

// ******************************************************************
// ImageSolverDialog: Configuration dialog of the solver
// ******************************************************************
function ImageSolverDialog( solverCfg, metadata )
{
   this.__base__ = Dialog;
   this.__base__();
   this.restyle();

   var labelWidth1 = this.font.width( "Right Ascension (hms):" + "M" );
   var radioLabelWidth = this.font.width( "Resolution (arcsec/px):" );
   var spinBoxWidth = 7*this.font.width( 'M' );

   this.solverCfg = solverCfg;

   this.helpLabel = new Label( this );
   this.helpLabel.frameStyle = FrameStyle_Box;
   this.helpLabel.minWidth = 45*this.font.width( 'M' );
   this.helpLabel.margin = 6;
   this.helpLabel.wordWrapping = true;
   this.helpLabel.useRichText = true;
   this.helpLabel.text =
      "<p><b>Image Plate Solver v" + SOLVERVERSION + "</b> &mdash; A script for plate-solving astronomical images.<br/>" +
      "The values are initialized from existing WCS coordinates or the keywords OBJCTRA, OBJCTDEC, FOCALLEN, XPIXSZ and DATE_OBS if present.<br/>" +
      "<br/>" +
      "Copyright &copy; 2012-2013 Andr&eacute;s del Pozo</p>";

   // Target object specifications

   var coordinatesTooltip = "<p>Initial equatorial coordinates. Must be inside the image.</p>";

   // RA

   this.ra_Label = new fieldLabel( this, "Right Ascension (hms):", labelWidth1 );

   var ra = (metadata.ra != null) ? DMSangle.FromAngle( metadata.ra*24/360) : new DMSangle;
   this.ra_h_SpinBox = new coordSpinBox( this, ra.deg, 23, spinBoxWidth, coordinatesTooltip,
                                         function( value ) { ra.deg = value; } );
   this.ra_min_SpinBox = new coordSpinBox( this, ra.min, 59, spinBoxWidth, coordinatesTooltip,
                                           function( value ) { ra.min = value; } );
   this.ra_sec_Edit = new Edit( this );
   this.ra_sec_Edit.text = format( "%.3f", ra.sec );
   this.ra_sec_Edit.toolTip = coordinatesTooltip;
   this.ra_sec_Edit.setFixedWidth( spinBoxWidth );
   this.ra_sec_Edit.onTextUpdated = function( value )
   {
      ra.sec = parseFloat( value );
   };

   this.search_Button = new PushButton( this );
   this.search_Button.text = "Search";
   this.search_Button.icon = ":/icons/find.png";

   this.ra_Sizer = new HorizontalSizer;
   this.ra_Sizer.spacing = 4;
   this.ra_Sizer.add( this.ra_Label );
   this.ra_Sizer.add( this.ra_h_SpinBox );
   this.ra_Sizer.add( this.ra_min_SpinBox );
   this.ra_Sizer.add( this.ra_sec_Edit );
   this.ra_Sizer.addStretch();
   this.ra_Sizer.add( this.search_Button );

   // DEC

   this.dec_Label = new fieldLabel( this, "Declination (dms):", labelWidth1 );

   var dec = (metadata.dec != null) ? DMSangle.FromAngle( metadata.dec ) : new DMSangle;
   this.dec_h_SpinBox = new coordSpinBox( this, dec.deg, 90, spinBoxWidth, coordinatesTooltip,
                                          function( value ) { dec.deg = value; } );
   this.dec_min_SpinBox = new coordSpinBox(this, dec.min, 59, spinBoxWidth, coordinatesTooltip,
                                          function( value ) { dec.min = value; } );
   this.dec_sec_Edit = new Edit( this );
   this.dec_sec_Edit.text = format( "%.2f", dec.sec );
   this.dec_sec_Edit.toolTip = coordinatesTooltip;
   this.dec_sec_Edit.setFixedWidth( spinBoxWidth );
   this.dec_sec_Edit.onTextUpdated = function( value )
   {
      dec.sec = parseFloat( value );
   };

   this.isSouth_CheckBox = new CheckBox( this );
   this.isSouth_CheckBox.text = "S";
   this.isSouth_CheckBox.checked = dec.sign < 0;
   this.isSouth_CheckBox.toolTip = "<p>When checked, the declination is negative (Southern hemisphere).</p>";
   this.isSouth_CheckBox.setFixedWidth( 40 );
   this.isSouth_CheckBox.onCheck = function( checked )
   {
      dec.sign = checked ? -1 : 1;
   };

   this.dec_Sizer = new HorizontalSizer;
   this.dec_Sizer.spacing = 4;
   this.dec_Sizer.add( this.dec_Label );
   this.dec_Sizer.add( this.dec_h_SpinBox );
   this.dec_Sizer.add( this.dec_min_SpinBox );
   this.dec_Sizer.add( this.dec_sec_Edit );
   this.dec_Sizer.add( this.isSouth_CheckBox );
   this.dec_Sizer.addStretch();

   this.search_Button.onClick = function ()
   {
      var search = new SearchCoordinatesDialog(null,true,false);
      search.windowTitle = "Online Coordinates Search"
      if (search.execute())
      {
         var object = search.object;
         if (object == null)
            return;
         ra = DMSangle.FromAngle(object.posEq.x / 15);
         this.dialog.ra_h_SpinBox.value = ra.deg;
         this.dialog.ra_min_SpinBox.value = ra.min;
         this.dialog.ra_sec_Edit.text = format("%.3f", ra.sec);

         dec = DMSangle.FromAngle(object.posEq.y);
         this.dialog.dec_h_SpinBox.value = dec.deg;
         this.dialog.dec_min_SpinBox.value = dec.min;
         this.dialog.dec_sec_Edit.text = format("%.2f", dec.sec);
         this.dialog.isSouth_CheckBox.checked = dec.sign < 0;
      }
   };

   // Epoch

   var epochTooltip = "<p>Date on which the image was taken.<br/>It is initialized from the DATE_OBS keyword.</p>";

   this.epoch_Label = new fieldLabel( this, "Epoch (ymd):", labelWidth1 );

   var epochArray = metadata.epoch == null ? [ 2000, 1, 1] : Math.jdToComplexTime( metadata.epoch );
   var epoch = new Date( epochArray[0], epochArray[1]-1, epochArray[2] );

   this.epoch_year_SpinBox = new SpinBox( this );
   this.epoch_year_SpinBox.minValue = 0;
   this.epoch_year_SpinBox.maxValue = 3000;
   this.epoch_year_SpinBox.value = epoch.getFullYear();
   this.epoch_year_SpinBox.toolTip = epochTooltip;
   this.epoch_year_SpinBox.setFixedWidth( spinBoxWidth );
   this.epoch_year_SpinBox.onValueUpdated = function( value )
   {
      epoch.setFullYear( value );
   };

   this.epoch_mon_SpinBox = new SpinBox( this );
   this.epoch_mon_SpinBox.minValue = 1;
   this.epoch_mon_SpinBox.maxValue = 12;
   this.epoch_mon_SpinBox.value = epoch.getMonth() + 1;
   this.epoch_mon_SpinBox.toolTip = epochTooltip;
   this.epoch_mon_SpinBox.setFixedWidth( spinBoxWidth );
   this.epoch_mon_SpinBox.onValueUpdated = function( value )
   {
      epoch.setMonth( value - 1 );
   };

   this.epoch_day_SpinBox = new SpinBox( this );
   this.epoch_day_SpinBox.minValue = 1;
   this.epoch_day_SpinBox.maxValue = 31;
   this.epoch_day_SpinBox.value = epoch.getDate();
   this.epoch_day_SpinBox.toolTip = epochTooltip;
   this.epoch_day_SpinBox.setFixedWidth( spinBoxWidth );
   this.epoch_day_SpinBox.onValueUpdated = function( value )
   {
      epoch.setDate( value );
   };

   this.epoch_Sizer = new HorizontalSizer;
   this.epoch_Sizer.spacing = 4;
   this.epoch_Sizer.add( this.epoch_Label );
   this.epoch_Sizer.add( this.epoch_year_SpinBox );
   this.epoch_Sizer.add( this.epoch_mon_SpinBox );
   this.epoch_Sizer.add( this.epoch_day_SpinBox );
   this.epoch_Sizer.addStretch();

   this.focal_RadioButton = new RadioButton( this );
   this.focal_RadioButton.checked = metadata.useFocal;
   this.focal_RadioButton.onCheck = function( value )
   {
      this.dialog.focal_Edit.enabled = value;
      metadata.useFocal = true;
   }

   this.focal_Label = new Label( this );
   this.focal_Label.textAlignment = TextAlign_Left|TextAlign_VertCenter;
   this.focal_Label.text = "Focal distance (mm):";
   this.focal_Label.setMinWidth( radioLabelWidth );
   this.focal_Label.mouseTracking = true;
   this.focal_Label.onMouseRelease = function()
   {
      this.dialog.focal_RadioButton.checked = true;
      this.dialog.focal_RadioButton.onCheck( true );
   };

   this.focal_Edit = new Edit( this );
   this.focal_Edit.text = format( "%g", metadata.focal );
   this.focal_Edit.toolTip = "<p>Effective focal length of the optical system in millimeters.<br />" +
      "It doesn't need to be the exact value, but it should not be more than 50% off (the closer the better).</p>";
   this.focal_Edit.setFixedWidth( spinBoxWidth );
   this.focal_Edit.enabled = metadata.useFocal;
   this.focal_Edit.onTextUpdated = function( value )
   {
      metadata.focal = parseFloat( value );
      if ( metadata.xpixsz )
      {
         metadata.resolution = (metadata.focal > 0) ? metadata.xpixsz/metadata.focal*0.18/Math.PI : 0;
         this.dialog.resolution_Edit.text = format( "%g", metadata.resolution*3600 );
      }
   };

   this.resolution_RadioButton = new RadioButton( this );
   this.resolution_RadioButton.checked = !metadata.useFocal;
   this.resolution_RadioButton.onCheck = function( value )
   {
      this.dialog.resolution_Edit.enabled = value;
      metadata.useFocal = false;
   };

   this.resolution_Label = new Label( this );
   this.resolution_Label.textAlignment = TextAlign_Left|TextAlign_VertCenter;
   this.resolution_Label.text = "Resolution (arcsec/px):";
   this.resolution_Label.setMinWidth( radioLabelWidth );
   this.resolution_Label.mouseTracking = true;
   this.resolution_Label.onMouseRelease = function()
   {
      this.dialog.resolution_RadioButton.checked = true;
      this.dialog.resolution_RadioButton.onCheck( true );
   };

   this.resolution_Edit = new Edit( this );
   if ( metadata.resolution != null )
      this.resolution_Edit.text = format( "%g", metadata.resolution*3600 );
   this.resolution_Edit.toolTip = "<p>Resolution of the image in arcseconds per pixel.<br />"+
      "It doesn't need to be the exact value, but it should not be more than 50% off (the closer the better).</p>";
   this.resolution_Edit.setFixedWidth( spinBoxWidth );
   this.resolution_Edit.enabled = !metadata.useFocal;
   this.resolution_Edit.onTextUpdated = function( value )
   {
      metadata.resolution = parseFloat( value )/3600;
      if ( metadata.xpixsz )
      {
         metadata.focal = (metadata.resolution > 0) ? metadata.xpixsz/metadata.resolution*0.18/Math.PI : 0;
         this.dialog.focal_Edit.text = format( "%g", metadata.focal );
      }
   };

   this.focal_Sizer = new HorizontalSizer;
   this.focal_Sizer.spacing = 4;
   this.focal_Sizer.add( this.focal_RadioButton );
   this.focal_Sizer.add( this.focal_Label );
   this.focal_Sizer.add( this.focal_Edit);
   this.focal_Sizer.addStretch();

   this.resol_Sizer = new HorizontalSizer;
   this.resol_Sizer.spacing = 4;
   this.resol_Sizer.add( this.resolution_RadioButton );
   this.resol_Sizer.add( this.resolution_Label );
   this.resol_Sizer.add( this.resolution_Edit);
   this.resol_Sizer.addStretch();

   this.scaleStack = new VerticalSizer;
   this.scaleStack.spacing = 4;
   this.scaleStack.add( this.focal_Sizer );
   this.scaleStack.add( this.resol_Sizer);

   this.scale_Label = new fieldLabel( this, "Image scale:", labelWidth1 );
   this.scale_Label.textAlignment = TextAlign_Right|TextAlign_VertCenter;

   this.scale_Control = new Label( this );
   this.scale_Control.textAlignment = TextAlign_VertCenter;
   this.scale_Control.text = '[';
   this.scale_Control.font = new Font( "DejaVu Sans Mono", this.font.pointSize*2 );

   this.scale_Sizer = new HorizontalSizer;
   this.scale_Sizer.spacing = 4;
   this.scale_Sizer.add( this.scale_Label );
   this.scale_Sizer.add( this.scale_Control );
   this.scale_Sizer.add( this.scaleStack );
   this.scale_Sizer.addStretch();

   // Pixel Size
   this.pixelSize_Label = new fieldLabel( this, "Pixel size (um):", labelWidth1 );

   this.pixelSizeX_Edit = new Edit( this );
   this.pixelSizeX_Edit.text = format( "%g", metadata.xpixsz );
   this.pixelSizeX_Edit.toolTip = "<p>Pixel size in micrometers. The image is assumed to have square pixels.</p>";
   this.pixelSizeX_Edit.setFixedWidth( spinBoxWidth );
   this.pixelSizeX_Edit.onTextUpdated = function( value )
   {
      if ( value != null )
      {
         var val = parseFloat( value );
         metadata.xpixsz = val;
         if ( val > 0 && val < 120 )
         {
            if ( metadata.useFocal )
            {
               metadata.resolution = (metadata.focal > 0) ? metadata.xpixsz/metadata.focal*0.18/Math.PI : 0;
               this.dialog.resolution_Edit.text = format( "%g", metadata.resolution*3600 );
            }
            else
            {
               metadata.focal = (metadata.resolution > 0) ? metadata.xpixsz/metadata.resolution*0.18/Math.PI : 0;
               this.dialog.focal_Edit.text = format( "%g", metadata.focal );
            }
         }
      }
   };

   this.pixelSize_Sizer = new HorizontalSizer;
   this.pixelSize_Sizer.spacing = 4;
   this.pixelSize_Sizer.add( this.pixelSize_Label );
   this.pixelSize_Sizer.add( this.pixelSizeX_Edit );
   // this.pixelSize_Sizer.add( this.pixelSize1_Label );
   // this.pixelSize_Sizer.add( this.pixelSizeY_Edit );
   this.pixelSize_Sizer.addStretch();

   this.dmParGroupBox = new GroupBox( this );
   this.dmParGroupBox.title = "Image parameters";
   this.dmParGroupBox.sizer = new VerticalSizer;
   this.dmParGroupBox.sizer.margin = 6;
   this.dmParGroupBox.sizer.spacing = 4;
   this.dmParGroupBox.sizer.add( this.ra_Sizer );
   this.dmParGroupBox.sizer.add( this.dec_Sizer );
   this.dmParGroupBox.sizer.add( this.epoch_Sizer );
   this.dmParGroupBox.sizer.add( this.scale_Sizer );
   this.dmParGroupBox.sizer.add( this.pixelSize_Sizer );
   this.dmParGroupBox.enabled = !solverCfg.onlyOptimize;

   // Model options

   // Local Catalog
   //this.dbPath_Label = new fieldLabel( this, "Star database:", labelWidth1 );
   this.dbPath_RadioButton = new RadioButton( this );
   this.dbPath_RadioButton.text = "Local star catalog:";
   this.dbPath_RadioButton.textAlignment = TextAlign_Right|TextAlign_VertCenter;
   this.dbPath_RadioButton.setMinWidth( labelWidth1 );
   this.dbPath_RadioButton.checked = this.solverCfg.catalogMode==0;
   this.dbPath_RadioButton.toolTip = "Use an locally stored star catalog";
   this.dbPath_RadioButton.onCheck = function( value )
   {
      this.dialog.dbPath_Edit.enabled = value;
      this.dialog.dbPath_Button.enabled = value;
      this.dialog.solverCfg.catalogMode = 0;
   }

   this.dbPath_Edit = new Edit( this );
   if ( this.solverCfg.databasePath )
      this.dbPath_Edit.text = this.solverCfg.databasePath;
   this.dbPath_Edit.setMinWidth( 300 );
   this.dbPath_Edit.enabled = this.solverCfg.catalogMode==0;
   this.dbPath_Edit.toolTip = "<p>Path to a star database file in StarGenerator format.<br />" +
      "The currently available star database files can be downloaded from: http://pixinsight.com/download/</p>";
   this.dbPath_Edit.onTextUpdated = function( value )
   {
     solverCfg.databasePath = value;
   };

   this.dbPath_Button = new ToolButton( this );
   this.dbPath_Button.icon = ":/icons/select-file.png";
   this.dbPath_Button.toolTip = "<p>Select a StarGenerator database file.</p>";
   this.dbPath_Button.enabled = this.solverCfg.catalogMode==0;
   this.dbPath_Button.onClick = function()
   {
      var gdd = new OpenFileDialog;
      gdd.initialPath = this.dialog.dbPath_Edit.text;
      gdd.caption = "Select Star Database Path";
      gdd.filters = [["Star database files", "*.bin"]];
      if ( gdd.execute() )
      {
         solverCfg.databasePath = gdd.fileName;
         this.dialog.dbPath_Edit.text = gdd.fileName;
      }
   };

   this.dbPath_Sizer = new HorizontalSizer;
   this.dbPath_Sizer.spacing = 4;
   this.dbPath_Sizer.add( this.dbPath_RadioButton );
   this.dbPath_Sizer.add( this.dbPath_Edit, 100 );
   this.dbPath_Sizer.add( this.dbPath_Button );

   // VizieR Catalog
   //this.dbPath_Label = new fieldLabel( this, "Star database:", labelWidth1 );
   this.vizier_RadioButton = new RadioButton( this );
   this.vizier_RadioButton.text = "VizieR star catalog:";
   this.vizier_RadioButton.textAlignment = TextAlign_Right|TextAlign_VertCenter;
   this.vizier_RadioButton.setMinWidth( labelWidth1 );
   this.vizier_RadioButton.checked = this.solverCfg.catalogMode==1;
   this.vizier_RadioButton.toolTip = "Use an online VizieR catalog server";
   this.vizier_RadioButton.onCheck = function( value )
   {
      this.dialog.mirror_Combo.enabled = value;
      this.dialog.catalog_Combo.enabled = value;
      this.dialog.solverCfg.catalogMode = 1;
   }

   this.catalog_Combo = new ComboBox(this);
   this.catalog_Combo.enabled = this.solverCfg.catalogMode==1;
   this.catalog_Combo.editEnabled = false;
   var toolTip = "<p>Available catalogs:</p><ul>";
   for(var i=0; i<this.solverCfg.availableCatalogs.length; i++){
      this.catalog_Combo.addItem(this.solverCfg.availableCatalogs[i].name);
      if(this.solverCfg.availableCatalogs[i].name==this.solverCfg.catalog)
         this.catalog_Combo.currentItem = i;
      toolTip+="<li>" + this.solverCfg.availableCatalogs[i].description + "</li>";
   }
   toolTip+="</ul>";

   this.catalog_Combo.toolTip = toolTip;
   this.catalog_Combo.onItemSelected = function ()
   {
      this.dialog.solverCfg.catalog = this.dialog.solverCfg.availableCatalogs[this.dialog.catalog_Combo.currentItem].name;
   }

   this.mirror_Combo = new ComboBox(this);
   this.mirror_Combo.enabled = this.solverCfg.catalogMode==1;
   this.mirror_Combo.editEnabled = false;
   this.mirror_Combo.toolTip = "<p>Select the best VizieR server for your location</p>";
   for ( var m = 0; m < VizierCatalog.mirrors.length; m++ )
   {
      this.mirror_Combo.addItem( VizierCatalog.mirrors[m].name );
      if ( VizierCatalog.mirrors[m].address == this.solverCfg.vizierServer )
         this.mirror_Combo.currentItem = parseInt( m );
   }
   this.mirror_Combo.onItemSelected = function()
   {
      this.dialog.solverCfg.vizierServer = VizierCatalog.mirrors[this.dialog.mirror_Combo.currentItem].address;
   };

   this.vizierSizer = new HorizontalSizer;
   this.vizierSizer.spacing = 4;
   this.vizierSizer.add( this.vizier_RadioButton );
   this.vizierSizer.add( this.catalog_Combo );
   this.vizierSizer.add( this.mirror_Combo );
   this.vizierSizer.addStretch();

   // Magnitude

   this.magnitude_Label = new fieldLabel( this, "Limit magnitude:", labelWidth1 );

   this.magnitude_SpinBox = new SpinBox( this );
   this.magnitude_SpinBox.minValue = 0;
   this.magnitude_SpinBox.maxValue = 30;
   this.magnitude_SpinBox.value = this.solverCfg.magnitude;
   this.magnitude_SpinBox.toolTip = "<p>Maximum star magnitude to use in the algorithm.<br/>" +
      "For wider fields, use lower values.</p>";
   this.magnitude_SpinBox.setFixedWidth( spinBoxWidth );
   this.magnitude_SpinBox.onValueUpdated = function( value )
   {
      solverCfg.magnitude = value;
   };

   this.magnitude_Sizer = new HorizontalSizer;
   this.magnitude_Sizer.spacing = 4;
   this.magnitude_Sizer.add( this.magnitude_Label );
   this.magnitude_Sizer.add( this.magnitude_SpinBox );
   this.magnitude_Sizer.addStretch();

   // Advanced controls
   this.advanced_Section = new SectionBar(this, "Advanced parameters");
   this.advanced_Control = new Control(this);
   this.advanced_Control.sizer = new VerticalSizer;
   this.advanced_Control.sizer.spacing = 4;
   this.advanced_Section.setSection(this.advanced_Control);
   this.advanced_Control.hide();

   // Align Algorithm
   this.alignAlgorithm_Label = new fieldLabel(this, "Align algorithm:", labelWidth1);

   this.alignAlgorithm_Combo = new ComboBox(this);
   this.alignAlgorithm_Combo.editEnabled = false;
   this.alignAlgorithm_Combo.addItem("Triangles");
   this.alignAlgorithm_Combo.addItem("Polygons");
   this.alignAlgorithm_Combo.currentItem = solverCfg.alignAlgorithm == AlignAlgorithm.prototype.Polygon ? 1 : 0;
   this.alignAlgorithm_Combo.toolTip = "<p>This parameter sets the algorithm used by the alignment step. There are two options:</p>" +
      "<ul><li><b>Triangles</b>: Uses a triangle similarity algorithm which is fast, works in most images but have problems in images with strong distortions</li>" +
      "<li><b>Polygons</b>: Uses an algorithm based on the comparison of polygons which is more tolerant to distortions and scale differences, but <i><u>it doesn't work with mirrored images</u></i>.</li></ul>";
   this.alignAlgorithm_Combo.onItemSelected = function ()
   {
      this.dialog.solverCfg.alignAlgorithm = this.dialog.alignAlgorithm_Combo.currentItem;
   }

   this.alignAlgorithm_Sizer = new HorizontalSizer;
   this.alignAlgorithm_Sizer.spacing = 4;
   this.alignAlgorithm_Sizer.add( this.alignAlgorithm_Label );
   this.alignAlgorithm_Sizer.add( this.alignAlgorithm_Combo );
   this.alignAlgorithm_Sizer.addStretch();


   // Iterations
   this.iterations_Label = new fieldLabel(this, "Maximum iterations:", labelWidth1);

   this.iterations_SpinBox = new SpinBox( this );
   this.iterations_SpinBox.minValue = 1;
   this.iterations_SpinBox.maxValue = 20;
   this.iterations_SpinBox.value = this.solverCfg.maxIterations;
   this.iterations_SpinBox.toolTip = "<p>Maximum number of iterations of the algorithm.</p>";
   this.iterations_SpinBox.setFixedWidth( spinBoxWidth );
   this.iterations_SpinBox.onValueUpdated = function( value )
   {
      solverCfg.maxIterations = value;
   };

   this.iterations_Sizer = new HorizontalSizer;
   this.iterations_Sizer.spacing = 4;
   this.iterations_Sizer.add( this.iterations_Label );
   this.iterations_Sizer.add( this.iterations_SpinBox );
   this.iterations_Sizer.addStretch();

   // Polynomial Degree

   this.degree_Label = new fieldLabel(this, "Polynomial degree:", labelWidth1);

   this.degree_SpinBox = new SpinBox( this );
   this.degree_SpinBox.minValue = 1;
   this.degree_SpinBox.maxValue = 9;
   this.degree_SpinBox.value = this.solverCfg.polyDegree;
   this.degree_SpinBox.toolTip = "<p>Degree of the polynomial used for translating coordinates.<br/>"+
      "The WCS standard only supports degree 1 polynomials. When a larger value is used, ImageSolver "+
      "stores the polynomial coefficients in nonstandard keywords. For compatibility reasons, a degree 1" +
      "polynomial is also calculated and stored in the WCS keywords.</p>";
   this.degree_SpinBox.setFixedWidth( spinBoxWidth );
   this.degree_SpinBox.onValueUpdated = function( value )
   {
      solverCfg.polyDegree = value;
      this.dialog.showDistortion_Check.visible = value>1;
   };

   this.showDistortion_Check = new CheckBox( this );
   this.showDistortion_Check.text = "Show distortion map";
   this.showDistortion_Check.checked = this.solverCfg.showDistortion!=null && this.solverCfg.showDistortion;
   this.showDistortion_Check.visible = this.solverCfg.polyDegree > 1;
   this.showDistortion_Check.toolTip = "<p>When the degree is larger that 1 this option generates a distortion map that "+
      "shows the difference between the lineal solution and higher degree polynomial.</p>";
   this.showDistortion_Check.onCheck = function( checked )
   {
      solverCfg.showDistortion = checked;
   };

   this.degree_Sizer = new HorizontalSizer;
   this.degree_Sizer.spacing = 4;
   this.degree_Sizer.add( this.degree_Label );
   this.degree_Sizer.add( this.degree_SpinBox );
   this.degree_Sizer.add( this.showDistortion_Check);
   this.degree_Sizer.addStretch();

   // Distortion template
   this.distortion_Label = new fieldLabel(this, "Distortion template:", labelWidth1);

   this.distortion_Combo = new ComboBox(this);
   this.distortion_Combo.editEnabled = false;
   this.distortion_Combo.toolTip = "<p>When a distortion template is selected, the solver uses the template " +
      "for modeling the distortion of the image. The template image must have been solved using a polynomial degree " +
      "greater than one and it must have the same dimensions as the image to solve. It should have been taken " +
      "with the same camera and lenses at the same focal and aperture.</p>"
   this.distortion_Combo.addItem("<< Not used >>");
   this.distortion_Combo.currentItem = 0;
   var windows = ImageWindow.windows;
   for (var i = 0; i < windows.length; i++)
   {
      var wmetadata = new ImageMetadata();
      wmetadata.ExtractMetadata(windows[i]);
      if (wmetadata.ref_I_G && wmetadata.ref_I_G.polDegree && wmetadata.ref_I_G.polDegree > 1 &&
         metadata.width == wmetadata.width && metadata.height == wmetadata.height)
      {
         this.distortion_Combo.addItem(windows[i].mainView.id);
         if (this.solverCfg.distortionTemplate && windows[i].mainView.id == this.solverCfg.distortionTemplate)
            this.distortion_Combo.currentItem = this.distortion_Combo.numberOfItems - 1;
      }
   }
   if (this.distortion_Combo.currentItem == 0)
      this.solverCfg.distortionTemplate = null;
   this.distortion_Combo.enabled = !this.solverCfg.onlyOptimize;
   this.distortion_Combo.onItemSelected = function ()
   {
      if (this.currentItem == 0)
      {
         this.dialog.solverCfg.distortionTemplate = null;
         this.dialog.optimize_CheckBox.enabled = true;
      }else{
         this.dialog.solverCfg.distortionTemplate = this.itemText(this.currentItem);
         this.dialog.optimize_CheckBox.enabled = false;
      }
   }

   this.distortion_Sizer = new HorizontalSizer;
   this.distortion_Sizer.spacing = 4;
   this.distortion_Sizer.add(this.distortion_Label);
   this.distortion_Sizer.add(this.distortion_Combo);
   this.distortion_Sizer.addStretch();


   // Star detection (sensitivity)
   this.sensitivity_Control = new NumericControl( this );
   this.sensitivity_Control.real = true;
   this.sensitivity_Control.label.text = "Star sensitivity:";
   this.sensitivity_Control.label.minWidth = labelWidth1;
   this.sensitivity_Control.setRange( -3, 3 );
   this.sensitivity_Control.slider.setRange( 0, 1000 );
   this.sensitivity_Control.slider.minWidth = 250;
   this.sensitivity_Control.setPrecision(2);
   this.sensitivity_Control.edit.minWidth = spinBoxWidth;
   this.sensitivity_Control.setValue( this.solverCfg.sensitivity );
   this.sensitivity_Control.toolTip = "<p>Star detectection sensitivity. Increase the value to detect less stars.</p>";
   this.sensitivity_Control.onValueUpdated = function (value) { solverCfg.sensitivity = value; };

   this.showStars_Check = new CheckBox( this );
   this.showStars_Check.text = "Show stars";
   this.showStars_Check.checked = this.solverCfg.showStars;
   this.showStars_Check.toolTip = "<p>When marked generates a new image with marks on the position of the detected stars in the original image.<br />It is useful for evaluating the value of the sensitivity</p>";
   this.showStars_Check.onCheck = function( checked )
   {
      solverCfg.showStars = checked;
   };


   this.detection_Sizer = new HorizontalSizer;
   this.detection_Sizer.spacing = 4;
   this.detection_Sizer.add( this.sensitivity_Control );
   this.detection_Sizer.add( this.showStars_Check );
   this.detection_Sizer.addStretch();

   // Update keywords

   this.updateKeys_CheckBox = new CheckBox( this );
   this.updateKeys_CheckBox.text = "Update FITS keywords";
   this.updateKeys_CheckBox.checked = this.solverCfg.updateKeywords != null && this.solverCfg.updateKeywords;
   this.updateKeys_CheckBox.toolTip = "<p>Update the keywords OBJCTRA, OBJCTDEC, FOCALLEN, XPIXSZ and YPIXSZ.</p>";
   this.updateKeys_CheckBox.onCheck = function( checked )
   {
      solverCfg.updateKeywords = checked;
   };

   this.updateKeys_Sizer = new HorizontalSizer;
   this.updateKeys_Sizer.spacing = 4;
   this.updateKeys_Sizer.addSpacing(labelWidth1);
   this.updateKeys_Sizer.add( this.updateKeys_CheckBox );
   this.updateKeys_Sizer.addStretch();

   // Write WCS keys

   this.writeWCS_CheckBox = new CheckBox( this );
   this.writeWCS_CheckBox .text = "Add WCS keywords";
   this.writeWCS_CheckBox.checked = this.solverCfg.writeWCS != null && this.solverCfg.writeWCS;
   this.writeWCS_CheckBox.toolTip = "<p>Writes the coordinates using the WCS convention.</p>";
   this.writeWCS_CheckBox.onCheck = function( checked )
   {
      solverCfg.writeWCS = checked;
   };

   this.writeWCS_Sizer = new HorizontalSizer;
   this.writeWCS_Sizer.spacing = 4;
   this.writeWCS_Sizer.addSpacing(labelWidth1);
   this.writeWCS_Sizer.add( this.writeWCS_CheckBox );
   this.writeWCS_Sizer.addStretch();

   // Error image

   this.residualsImg_CheckBox = new CheckBox( this );
   this.residualsImg_CheckBox .text = "Generate residuals image";
   this.residualsImg_CheckBox.checked = this.solverCfg.generateErrorImg != null && this.solverCfg.generateErrorImg;
   this.residualsImg_CheckBox.toolTip = "<p>Generates an image with the predicted position of the stars (green)" +
      "and arrows (red) pointing the actual position.<br/>" +
      "This image can be used to analyze the errors of the solution.</p>";
   this.residualsImg_CheckBox.onCheck = function( checked )
   {
      solverCfg.generateErrorImg = checked;
   };

   this.residualsImg_Sizer = new HorizontalSizer;
   this.residualsImg_Sizer.spacing = 4;
   this.residualsImg_Sizer.addSpacing(labelWidth1);
   this.residualsImg_Sizer.add( this.residualsImg_CheckBox );
   this.residualsImg_Sizer.addStretch();

   // Write WCS keys

   this.optimize_CheckBox = new CheckBox( this );
   this.optimize_CheckBox.text = "Only apply optimization";
   this.optimize_CheckBox.checked = this.solverCfg.onlyOptimize != null && this.solverCfg.onlyOptimize;
   this.optimize_CheckBox.toolTip = "<p>The solver assumes that the image is already solved and " +
      "it only optimizes the result using the current parameters.</p>";
   this.optimize_CheckBox.enabled = this.solverCfg.distortionTemplate==null || this.solverCfg.distortionTemplate.length==0;
   this.optimize_CheckBox.onCheck = function( checked )
   {
      solverCfg.onlyOptimize = checked;
      this.dialog.distortion_Combo.enabled = !checked;
      this.dialog.dmParGroupBox.enabled = !checked;
   };

   this.optimize_Sizer = new HorizontalSizer;
   this.optimize_Sizer.spacing = 4;
   this.optimize_Sizer.addSpacing(labelWidth1);
   this.optimize_Sizer.add( this.optimize_CheckBox );
   this.optimize_Sizer.addStretch();

   this.advanced_Control.sizer.add(this.alignAlgorithm_Sizer);
   this.advanced_Control.sizer.add(this.detection_Sizer);
   this.advanced_Control.sizer.add(this.iterations_Sizer);
   this.advanced_Control.sizer.add(this.degree_Sizer);
   this.advanced_Control.sizer.add(this.distortion_Sizer);
   this.advanced_Control.sizer.add(this.updateKeys_Sizer);
   this.advanced_Control.sizer.add(this.writeWCS_Sizer);
   this.advanced_Control.sizer.add(this.residualsImg_Sizer);
   this.advanced_Control.sizer.add(this.optimize_Sizer);

   this.dseParGroupBox = new GroupBox(this);
   this.dseParGroupBox.title = "Model Parameters";
   this.dseParGroupBox.sizer = new VerticalSizer;
   this.dseParGroupBox.sizer.margin = 6;
   this.dseParGroupBox.sizer.spacing = 4;
   this.dseParGroupBox.sizer.add(this.dbPath_Sizer);
   this.dseParGroupBox.sizer.add(this.vizierSizer);
   this.dseParGroupBox.sizer.add(this.magnitude_Sizer);
   this.dseParGroupBox.sizer.add(this.advanced_Section);
   this.dseParGroupBox.sizer.add(this.advanced_Control);

   this.Validate = function()
   {
      if (metadata.useFocal)
      {
         if ( metadata.focal <= 0 )
         {
            new MessageBox( "Invalid focal length", TITLE, StdIcon_Error ).execute();
            return false;
         }

         if ( metadata.xpixsz <= 0 || metadata.xpixsz > 120 )
         {
            new MessageBox( "Invalid pixel size", TITLE, StdIcon_Error ).execute();
            return false;
         }
      }

      if (!solverCfg.onlyOptimize  && (metadata.resolution == null || metadata.resolution <= 0 || metadata.resolution > 300/3600) )
      {
         new MessageBox( "Invalid image resolution", TITLE, StdIcon_Error ).execute();
         return false;
      }

      var raVal = ra.GetValue();
      if ( raVal < 0 || raVal > 24 )
      {
         new MessageBox( "Invalid right ascension", TITLE, StdIcon_Error ).execute();
         return false;
      }
      metadata.ra = raVal*360/24;

      var decVal = dec.GetValue();
      if ( decVal < -90 || decVal > +90 )
      {
         new MessageBox( "Invalid declination", TITLE, StdIcon_Error ).execute();
         return false;
      }
      metadata.dec = dec.GetValue();

      metadata.epoch = Math.complexTimeToJD( epoch.getFullYear(), epoch.getMonth()+1, epoch.getDate() );

      return true;
   };

   // usual control buttons

   this.newInstanceButton = new ToolButton( this );
   this.newInstanceButton.icon = ":/process-interface/new-instance.png";
   this.newInstanceButton.toolTip = "New Instance";
   this.newInstanceButton.onMousePress = function()
   {
      if( !this.dialog.Validate() )
         return;

      this.hasFocus = true;

      metadata.SaveParameters();
      solverCfg.SaveParameters();

      this.pushed = false;
      this.dialog.newInstance();
   };


   this.reset_Button = new ToolButton( this );
   //this.reset_Button.text = "Reset";
   this.reset_Button.icon = ":/icons/reload.png";
   this.reset_Button.toolTip = "<p>Resets the settings to the default values.<br />"+
      "It closes the dialog and the script must be executed again.</p>";
   this.reset_Button.icon = ":/icons/reload.png";
   this.reset_Button.onClick = function()
   {
      var msg = new MessageBox( "Do you really want to reset the settings to their default value?",
         TITLE, StdIcon_Warning, StdButton_Yes, StdButton_No );
      var res = msg.execute();
      if( res == StdButton_Yes )
      {
         this.dialog.solverCfg.ResetSettings();
         this.dialog.resetRequest = true;
         this.dialog.cancel();
      }
   };

   this.ok_Button = new PushButton( this );
   this.ok_Button.text = "OK";
   this.ok_Button.icon = ":/icons/ok.png";
   this.ok_Button.cursor = new Cursor( StdCursor_Checkmark );
   this.ok_Button.onClick = function()
   {
      if( !this.dialog.Validate() )
         return;

      this.dialog.ok();
   };

   this.cancel_Button = new PushButton( this );
   this.cancel_Button.text = "Cancel";
   this.cancel_Button.icon = ":/icons/cancel.png";
   this.cancel_Button.cursor = new Cursor( StdCursor_Crossmark );
   this.cancel_Button.onClick = function()
   {
     this.dialog.cancel();
   };

   this.buttons_Sizer = new HorizontalSizer;
   this.buttons_Sizer.spacing = 6;
   this.buttons_Sizer.add( this.newInstanceButton );
   this.buttons_Sizer.add( this.reset_Button );
   this.buttons_Sizer.addStretch();
   this.buttons_Sizer.add( this.ok_Button );
   this.buttons_Sizer.add( this.cancel_Button );

   // Global sizer

   this.sizer = new VerticalSizer;
   this.sizer.margin = 8;
   this.sizer.spacing = 6;
   this.sizer.add( this.helpLabel );
   this.sizer.addSpacing( 4 );
   this.sizer.add( this.dmParGroupBox );
   this.sizer.add( this.dseParGroupBox );
   this.sizer.add( this.buttons_Sizer );

   this.windowTitle = "Image Plate Solver Script";
   this.adjustToContents();
   this.setFixedSize();
}

ImageSolverDialog.prototype = new Dialog;

// ******************************************************************
// ImageSolver: It implements the plate solving algorithm
// ******************************************************************
function ImageSolver()
{
   var activeWindow;
   var error;
   this.solverCfg = new SolverConfiguration(SETTINGS_MODULE_SCRIPT);
   this.metadata = new ImageMetadata(SETTINGS_MODULE_SCRIPT);

   // Initializes the image solver
   // If the parameter prioritizeSettings is defined and true the solver uses the values
   // stored in the preferences instead the values obtained from the image.
   this.Init = function( w, prioritizeSettings )
   {
      if( !w || !w.isWindow)
         throw Error( "The script requires an image" );
      this.activeWindow = w;

      this.solverCfg.LoadSettings();
      this.solverCfg.LoadParameters();

      if(prioritizeSettings)
      {
         this.metadata.ExtractMetadata( this.activeWindow );
         this.metadata.LoadSettings();
         this.metadata.LoadParameters();
      } else {
         this.metadata.LoadSettings();
         this.metadata.LoadParameters();
         this.metadata.ExtractMetadata( this.activeWindow );
      }
   };

   this.DoAlign = function( view )
   {
      var align = new StarAlignment;
      align.referenceImage = STAR_CSV_FILE;
      align.referenceIsFile = true;
      align.writeKeywords = false;
      //align.matcherTolerance = 0.01; //0.0030;
      //align.ransacTolerance = 8.0; //6.00;
      align.useSurfaceSplines = true;
      align.sensitivity = Math.pow(10, this.solverCfg.sensitivity);
      align.noGUIMessages = true;
      align.useTriangles = this.solverCfg.alignAlgorithm == AlignAlgorithm.prototype.Triangles;
      align.polygonSides = 5;
      //align.onError = StarAlignment.prototype.Continue;

      if ( this.solverCfg.showStars )
      {
         align.mode = StarAlignment.prototype.DrawStars;
         align.executeOn( view, false );
      }

      align.mode = StarAlignment.prototype.OutputMatrix;

      if(align.useTriangles)
         console.writeln("Using Triangle similarity algorithm");
      else
         console.writeln("Using Polygon algorithm with ", align.polygonSides, " sides");

      var res=align.executeOn( view, false );
      if(!res)
         throw "The image could not be aligned with the reference star field";

      var aligndata = align.outputData[0].slice( 11, 17 );
      aligndata[6] = 0;
      aligndata[7] = 0;
      aligndata[8] = 1;

      // TEMPORAL: StarAlignment uses a different convention for the origin
      // of the coordinates of the stars.
      // BugReport: http://pixinsight.com/forum/index.php?topic=4371.0
      aligndata[2] += 0.5;
      aligndata[5] += 0.5;
      // ***

      return new Matrix( aligndata, 3, 3 );
   };

   this.GenerateTemplate = function( )
   {
      var templateWidth, templateHeight;
 /*     if ( this.solverCfg.templateSizeFactor > 1 )
      {*/
         //var templateSize = Math.floor( Math.max( this.metadata.width, this.metadata.height )*this.solverCfg.templateSizeFactor );
         var templateSize = Math.max( this.metadata.width, this.metadata.height );
         templateWidth = templateSize;
         templateHeight = templateSize;
/*      }
      else
      {
         templateWidth = Math.max( 256, this.metadata.width );
         templateHeight = Math.max( 256, this.metadata.height );
      }*/

      this.metadata.ref_S_G = new Matrix(
         -this.metadata.resolution,  0,                   this.metadata.resolution*templateWidth/2,
          0,                   -this.metadata.resolution, this.metadata.resolution*templateHeight/2,
          0,                    0,                   1 );

      this.metadata.projection = new Gnomonic( 180/Math.PI, this.metadata.ra, this.metadata.dec );

      if ( this.solverCfg.catalogMode==0 )
      {
         var generator = new StarGenerator;

         if ( this.solverCfg.databasePath )
            generator.starDatabasePath = this.solverCfg.databasePath;
         generator.centerRA = this.metadata.ra;
         generator.centerDec = this.metadata.dec;
         generator.epoch = this.metadata.epoch;
         generator.projectionSystem = StarGenerator.prototype.Gnomonic;

         if ( this.metadata.useFocal )
         {
            generator.focalLength = this.metadata.focal;
            generator.pixelSize = this.metadata.xpixsz;
            this.metadata.resolution = this.metadata.ResolutionFromFocal( this.metadata.focal );
         }
         else
         {
            if ( this.metadata.xpixsz > 0 )
            {
               generator.focalLength = this.metadata.FocalFromResolution( this.metadata.resolution );
               generator.pixelSize = this.metadata.xpixsz;
            }
            else
            {
               generator.pixelSize = 10;
               generator.focalLength = generator.pixelSize/this.metadata.resolution*0.18/Math.PI;
            }
         }

         generator.limitMagnitude = this.solverCfg.magnitude;
         generator.outputMode = StarGenerator.prototype.Output_CSVFile;
         generator.outputFilePath = STAR_CSV_FILE;
         generator.sensorWidth = templateWidth;
         generator.sensorHeight = templateHeight;
         generator.executeGlobal();
      } else {
         if( !this.catalog )
            this.catalog = __catalogRegister__.GetCatalog(this.solverCfg.catalog);

         this.catalog.magMax = this.solverCfg.magnitude;
         this.catalog.Load( this.metadata, this.solverCfg.vizierServer );
         var ref_G_S = this.metadata.ref_S_G.inverse();

         var file = new File;
         file.createForWriting( STAR_CSV_FILE );
         file.outTextLn( templateWidth+","+templateHeight );
         var elements = this.catalog.objects;
         for( var i=0; i<elements.length; i++ )
         {
            if ( elements[i] )
            {
               var flux = Math.pow( 2.512, -1.5-elements [i].magnitude );
               var pos_S = ref_G_S.Apply( this.metadata.projection.Direct( elements [i].posRD) );
               if ( pos_S.x>0 && pos_S.x<templateWidth && pos_S.y>0 && pos_S.y<templateHeight )
                  file.outTextLn( format( "%f,%f,%g", pos_S.x, pos_S.y, flux ) );
            }
         }
         file.close();
      }
   };

   this.DoIterationSA = function( window )
   {
      console.writeln("Starting StarAlignment iteration");
      // Render a star field around the original coordinates
      this.GenerateTemplate( );

      try
      {
         // Align the image against the star field
         // Returns the matrix that transforms from the pixels of the star field (S)
         // to the pixels of the image (I)
         var align_S_I = this.DoAlign( window.currentView );
         var align_I_S = align_S_I.inverse();

         var newMetadata = this.metadata.Clone();

         // Construction of the matrix that transforms from the pixels of the star field (S)
         // to pixels in Gnomonic projection (G)
         newMetadata.ref_I_G_lineal = this.metadata.ref_S_G.mul(align_I_S);
         newMetadata.ref_I_G = ReferNPolyn.prototype.FromLinealMatrix(newMetadata.ref_I_G_lineal);
         newMetadata.ref_G_I = ReferNPolyn.prototype.FromLinealMatrix(newMetadata.ref_I_G_lineal.inverse());

         // Find the celestial coordinates (RD) of the center of the original image
         // First transform from I to G and then unprojects the gnomonic coords (G) to celestial (RD)
         var centerG = newMetadata.ref_I_G.Apply( new Point( this.metadata.width/2, this.metadata.height/2 ) );
         var centerRD = newMetadata.projection.Inverse( centerG );
         if(centerRD.x<0)
            centerRD.x += 360;
         else if(centerRD.x>360)
            centerRD.x -= 360;
         newMetadata.ra = centerRD.x;
         newMetadata.dec = centerRD.y;
         var ref = newMetadata.ref_I_G_lineal;
         var resx = Math.sqrt(ref.at(0, 0) * ref.at(0, 0) + ref.at(0, 1) * ref.at(0, 1));
         var resy = Math.sqrt(ref.at(1, 0) * ref.at(1, 0) + ref.at(1, 1) * ref.at(1, 1));
         newMetadata.resolution = (resx + resy) / 2;
         newMetadata.focal = newMetadata.FocalFromResolution( newMetadata.resolution );
         newMetadata.useFocal = false;

         return newMetadata;
      }
      catch( ex )
      {
         console.writeln( "*** Error: ", ex );
         return null;
      }
   };

   this.DoIterationDistortion = function()
   {
      var distortionWindow = ImageWindow.windowById(this.solverCfg.distortionTemplate);
      var disortionMetadata = new ImageMetadata();
      disortionMetadata.ExtractMetadata(distortionWindow);

      var distortion = this.GetDistortion(disortionMetadata);
      var linealWindow = this.CreateLinealWindow(distortion);

      try{
         var newMetadata = this.DoIterationSA( linealWindow );
         if(!newMetadata)
            return null;

         var stars = this.DetectStars(linealWindow, newMetadata, null);

         // Translate pixels coords from lineal to distorted (original)
         for(var i=0; i<stars.actualCoords.length; i++)
            if(stars.actualCoords[i])
               stars.actualCoords[i]=distortion.ref_L_D.Apply(stars.actualCoords[i]);

         // Create new referentiation matrices
         var polDegree = distortion.ref_L_D.polDegree;
         newMetadata.ref_I_G = MultipleLinearRegression(polDegree, stars.actualCoords, stars.coordsG);
         newMetadata.ref_I_G_lineal = MultipleLinearRegression(1, stars.actualCoords, stars.coordsG).ToLinealMatrix();
         newMetadata.ref_G_I = MultipleLinearRegression(polDegree, stars.coordsG, stars.actualCoords);

         return [newMetadata, stars];
      } finally{
         linealWindow.forceClose();
      }
   }

   this.CreateLinealWindow = function(distortion)
   {
      console.writeln("Create undistorted image");
      var width=this.activeWindow.mainView.image.width;
      var height=this.activeWindow.mainView.image.height;

      var cpoints = [];
      var incx = (width - 0.1) / Math.min(10, Math.round(width / 50));
      var incy = (height - 0.1) / Math.min(10, Math.round(height / 50));
      for (var y = 0; y < height; y += incy)
         for (var x = 0; x < width; x += incx)
         {
            var p_L = new Point(x, y);
            var p_D = distortion.ref_L_D.Apply(new Point(x, y));
            if (p_D.x >= 0 && p_D.x < width && p_D.y >= 0 && p_D.y < height)
               cpoints.push(
                  [p_L.x / width, p_L.y / height,
                     (p_D.x - p_L.x) / width, (p_D.y - p_L.y) / height]
               );
         }
      //console.writeln(JSON.stringify(cpoints));kk;
      console.writeln("Number of control points: ", cpoints.length);

      var greyWindow=null;
      var srcTmW=null;
      try
      {
         var targetWindow = this.activeWindow;
         if(this.activeWindow.mainView.image.numberOfChannels==3)
         {
            // Extract L channel. The chrominance data is not necessary for solving
            var channelExtr = new ChannelExtraction;
            channelExtr.colorSpace = ChannelExtraction.prototype.CIELab;
            channelExtr.channels = [ // enabled, id
               [true, "__tmpImageSolver_L"],
               [false, ""],
               [false, ""]
            ];
            channelExtr.sampleFormat = ChannelExtraction.prototype.f32;
            channelExtr.executeOn(this.activeWindow.mainView);
            targetWindow = greyWindow = ImageWindow.windowById("__tmpImageSolver_L");
         }

         srcTmW = new ImageWindow(width, height, 1, 8, false, false, "___tmp");

         var da = new DynamicAlignment;
         da.data = cpoints;
         da.sourceImageId = srcTmW.mainView.id;
         da.registeredImageId = "__tmpImageSolverLineal";
         da.registeredImageSampleFormat = DynamicAlignment.prototype.SameAsTarget;
         da.sourceImageWidth = width;
         da.sourceImageHeight = height;
         da.targetImageWidth = width;
         da.targetImageHeight = height;

         da.executeOn(targetWindow.mainView);
         var resWindow = ImageWindow.windowById("__tmpImageSolverLineal");

         return resWindow;
      } finally
      {
         if(srcTmW && srcTmW.isWindow)
            srcTmW.close();
         if(greyWindow && greyWindow.isWindow)
            greyWindow.forceClose();
      }
   }

   this.FindStarsInImage = function (window, predictedCoords)
   {
      var DPSF = new DynamicPSF;
      DPSF.views = [
         // id
         [window.mainView.id]
      ];
      var stars = [];
      var psf = [];
      var translateIdx = {};
      for (var i = 0; i < predictedCoords.length; i++)
      {
         stars.push(
            [0, 0, DynamicPSF.prototype.Star_DetectedOk,
               predictedCoords[i].x - 2, predictedCoords[i].y - 2,
               predictedCoords[i].x + 2, predictedCoords[i].y + 2,
               predictedCoords[i].x, predictedCoords[i].y]);
         translateIdx[psf.length] = i;
         psf.push(
            [psf.length, DynamicPSF.prototype.Function_Moffat4, false, DynamicPSF.prototype.PSF_FittedOk,
               0.022934, 1.190503,
               predictedCoords[i].x, predictedCoords[i].y,
               3.174, 3.043, 166.57, 4.00, 3.826e-003]);
      }
      DPSF.stars = stars;
      DPSF.psf = psf;
      DPSF.searchRadius = 4;
      DPSF.autoPSF = false;
      DPSF.gaussianPSF = true;
      DPSF.circularPSF = false;
      DPSF.moffatPSF = DPSF.moffat10PSF = DPSF.moffat8PSF = DPSF.moffat6PSF =
         DPSF.moffat4PSF = DPSF.moffat25PSF = DPSF.moffat15PSF =
            DPSF.lorentzianPSF = false;
      //console.writeln(DPSF.toSource());
      var res = DPSF.executeGlobal();
      psf = DPSF.psf;
      //console.writeln("OK imgX imgY dpsfX dpsfY sigma starX starY");
      var actualCoords = Array(predictedCoords.length);
      for (var i = 0; i < psf.length; i++)
      {
         var starIdx = translateIdx[psf[i][0]];
         if (psf[i][3] == DynamicPSF.prototype.PSF_FittedOk)
            actualCoords[starIdx] = new Point(psf[i][6], psf[i][7]);
         //console.writeln(format("idx:%d Pred:%ls Act:%ls", starIdx, predictedCoords[starIdx].toString(),actualCoords[starIdx].toString()));
      }

      // Remove stars that could not be fitted
      for (var i = 0; i < predictedCoords.length; i++)
         if (actualCoords[i] == null)
//         {
//            console.writeln(format("idx:%d Pred:%ls Act:---", i, predictedCoords[i].toString()));
            predictedCoords[i] = null;
//         } else
//            console.writeln(format("idx:%d Pred:%ls Act:%ls", i, predictedCoords[i].toString(),actualCoords[i].toString()));
      return actualCoords;
   }

   this.ApplySTF = function(view, stf)
   {
      var low=(stf[0][1]+stf[1][1]+stf[2][1])/3;
      var mtf=(stf[0][0]+stf[1][0]+stf[2][0])/3;
      var hgh=(stf[0][2]+stf[1][2]+stf[2][2])/3;

      if ( low > 0 || mtf != 0.5 || hgh != 1 ) // if not an identity transformation
      {
         var HT = new HistogramTransformation;
         HT.H = [[  0, 0.5,   1, 0, 1],
            [  0, 0.5,   1, 0, 1],
            [  0, 0.5,   1, 0, 1],
            [low, mtf, hgh, 0, 1],
            [  0, 0.5,   1, 0, 1]];

         HT.executeOn( view, false ); // no swap file
      }
   }

   this.DrawErrors = function(metadata, stars)
   {
      if(!stars)
         return;
      console.writeln("Creating error map");

      // Draw errors in a new bitmap
      var bmp = new Bitmap(metadata.width, metadata.height);

      //Copy the source image to the error image
      var imageOrg = this.activeWindow.mainView.image;
      var tmpW = new ImageWindow(metadata.width, metadata.height, imageOrg.numberOfChannels, this.activeWindow.bitsPerSample, this.activeWindow.isFloatSample, imageOrg.isColor, "___tmp");
      tmpW.mainView.beginProcess(UndoFlag_NoSwapFile);
      tmpW.mainView.image.apply(imageOrg);
      this.ApplySTF(tmpW.mainView, this.activeWindow.mainView.stf);
      tmpW.mainView.endProcess();
      bmp.assign(tmpW.mainView.image.render());
      tmpW.close();

      //bmp.fill(0xff000000);
      var g = new VectorGraphics(bmp);
      g.antialiasing = true;
      var linePen = new Pen(0xffff4040, 1);
      var starPen = new Pen(0xff40ff40, 1);
      var starBrush = new Brush(0xff40ff40);
      for(var i=0; i<stars.actualCoords.length; i++)
      {
         if(stars.actualCoords[i])
         {
            var predicted = metadata.Convert_RD_I(stars.starCoords[i]);
            //var arrow= new Point(
            //   stars.actualCoords[i].x+(c2.x-stars.actualCoords[i].x)*2,
            //   stars.actualCoords[i].y+(c2.y-stars.actualCoords[i].y)*2);
            var arrow= new Point(
               predicted.x+(stars.actualCoords[i].x-predicted.x)*1,
               predicted.y+(stars.actualCoords[i].y-predicted.y)*1);
            g.pen=linePen;
            //g.drawLine(stars.actualCoords[i],arrow);
            g.drawLine(predicted,arrow);
            g.brush=starBrush;
            //g.fillEllipse(stars.actualCoords[i].x-1,stars.actualCoords[i].y-1,stars.actualCoords[i].x+1,stars.actualCoords[i].y+1);
            //g.fillEllipse(predicted.x-1,predicted.y-1,predicted.x+1,predicted.y+1);
            g.pen=starPen;
            g.drawLine(predicted.x-10,predicted.y,predicted.x-5,predicted.y);
            g.drawLine(predicted.x+10,predicted.y,predicted.x+5,predicted.y);
            g.drawLine(predicted.x,predicted.y-10,predicted.x,predicted.y-5);
            g.drawLine(predicted.x,predicted.y+10,predicted.x,predicted.y+5);
         }
      }
      g.end();

      // Create an ImageWindow for showing the bitmap
      var errW = new ImageWindow(metadata.width, metadata.height,
         3, 8, false, true, this.activeWindow.mainView.id+ "_Errors");
      errW.mainView.beginProcess(UndoFlag_NoSwapFile);

      // Blend annotation with target image
      errW.mainView.image.blend(bmp);

      // Copy keywords to target image
      errW.keywords = this.activeWindow.keywords;

      errW.mainView.endProcess();
      errW.show();
   };

   this.DrawDistortions = function(metadata)
   {
      console.writeln("Creating distortion map");

      // Draw errors in a new bitmap
      var bmp = new Bitmap(metadata.width, metadata.height);

      bmp.fill(0xffffffff);
      var g = new VectorGraphics(bmp);
      g.antialiasing = true;
      var linePen = new Pen(0xff000000, 2);
      var starPen = new Pen(0xff800000, 2);
      g.pen=starPen;
      var cellSize=Math.min(metadata.width, metadata.height)/40;
      cellSize=Math.max(40,cellSize);

      for(var y=0; y<metadata.height; y+=cellSize)
         for(var x=0; x<metadata.width; x+=cellSize)
         {
            var posLinealI = new Point(x+cellSize/2,y+cellSize/2);
            var posG = metadata.ref_I_G_lineal.Apply(posLinealI);
            var posDistortI = metadata.ref_G_I.Apply(posG);
            var arrow = new Point(posDistortI.x+(posLinealI.x-posDistortI.x)*10, posDistortI.y+(posLinealI.y-posDistortI.y)*10);
            g.drawLine(posDistortI, arrow);
            g.drawEllipse(posDistortI.x-1,posDistortI.y-1,posDistortI.x+1,posDistortI.y+1);
         }
      g.pen=linePen;
      for (var y = 0; y-cellSize <= metadata.height; y += cellSize)
      {
         var pts = [];
         for (var x = 0; x-cellSize <= metadata.width; x += cellSize)
         {
            var posLinealI = new Point(x, y);
            var posG = metadata.ref_I_G_lineal.Apply(posLinealI);
            pts.push(metadata.ref_G_I.Apply(posG));
         }
         g.drawPolyline(pts);
      }
      for (var x = 0; x-cellSize <= metadata.width; x += cellSize)
      {
         var pts = [];
         for (var y = 0; y-cellSize <= metadata.height; y += cellSize)
         {
            var posLinealI = new Point(x, y);
            var posG = metadata.ref_I_G_lineal.Apply(posLinealI);
            pts.push(metadata.ref_G_I.Apply(posG));
         }
         g.drawPolyline(pts);
      }
      g.end();

      // Create an ImageWindow for showing the bitmap
      var errW = new ImageWindow(metadata.width, metadata.height,
         3, 8, false, true, this.activeWindow.mainView.id+ "_Distortions");
      errW.mainView.beginProcess(UndoFlag_NoSwapFile);

      // Blend annotation with target image
      errW.mainView.image.blend(bmp);

      // Copy keywords to target image
      errW.keywords = this.activeWindow.keywords;

      errW.mainView.endProcess();
      errW.show();
   };

   this.DetectStars = function (window, metadata, clipArea)
   {
      if (clipArea == null)
         clipArea = new Rect(0, 0, metadata.width, metadata.height);
      // Load stars
      var catalogObjects;
      if ( this.solverCfg.catalogMode==0 )
      {
         var templateSize = Math.max(metadata.width, metadata.height) * Math.sqrt(2);
         var generator = new StarGenerator;

         if ( this.solverCfg.databasePath )
            generator.starDatabasePath = this.solverCfg.databasePath;
         generator.centerRA = metadata.ra;
         generator.centerDec = metadata.dec;
         generator.epoch = metadata.epoch;
         generator.projectionSystem = StarGenerator.prototype.Gnomonic;
         generator.pixelSize = 10;
         generator.focalLength = generator.pixelSize/metadata.resolution*0.18/Math.PI;
         generator.limitMagnitude = this.solverCfg.magnitude;
         generator.outputMode = StarGenerator.prototype.Output_CSVFile;
         generator.outputFilePath = STAR_CSV_FILE;
         generator.sensorWidth = templateSize;
         generator.sensorHeight = templateSize;
         generator.executeGlobal();

         var ref_S_G = new Matrix(
            -metadata.resolution, 0,                   metadata.resolution*templateSize/2,
            0,                   -metadata.resolution, metadata.resolution*templateSize/2,
            0,                    0,                   1 );

         var projection = new Gnomonic( 180/Math.PI, metadata.ra, metadata.dec );

         // Read the positions of the stars from the file written by StarGenerator
         var lines= File.readLines(STAR_CSV_FILE);
         catalogObjects=[];
         for(var i=0; i<lines.length; i++)
         {
            //console.writeln("Line: ", lines[i]);
            var tokens=lines[i].split(",");
            if(tokens.length!=3)
               continue;

            var posS = new Point(parseFloat(tokens[0]), parseFloat(tokens[1]));
            var posG = ref_S_G.Apply(posS);
            var posRD = projection.Inverse(posG);
            catalogObjects.push({posRD:posRD});
         }
      } else {
         if (!this.catalog)
            this.catalog = __catalogRegister__.GetCatalog(this.solverCfg.catalog);

         //catalog.magMin = 15;
         this.catalog.magMax = this.solverCfg.magnitude;
         this.catalog.Load(metadata, this.solverCfg.vizierServer);
         catalogObjects = this.catalog.objects;
      }

      // Create the arrays starCoords, coordsG and predictedCoords
      var result = {starCoords:[], coordsG:[]};
      var predictedCoords = []; // Pixel coordinates of the catalog stars obtained using the current referentiation
      result.projection = new Gnomonic(180 / Math.PI, metadata.ra, metadata.dec); // New projection using the new center
      for (var i = 0; i < catalogObjects.length; i++)
      {
         if (catalogObjects[i])
         {
            var posI = metadata.Convert_RD_I(catalogObjects[i].posRD);
            if(posI && posI.x>=clipArea.left && posI.y>=clipArea.top && posI.x<=clipArea.right && posI.y<=clipArea.bottom)
            {
               predictedCoords.push(posI);
               result.coordsG.push(result.projection.Direct(catalogObjects[i].posRD));
               result.starCoords.push(catalogObjects[i].posRD);
            }
         }
      }

      // Find the stars in the image using predictedCoords as starting point
      result.actualCoords = this.FindStarsInImage(window, predictedCoords);

      // Calculate errors
      result.errors2 = Array(predictedCoords.length);
      var stddev2=0;
      var numFitted=0;
      for (var i = 0; i < predictedCoords.length; i++)
      {
         if (predictedCoords[i] && result.actualCoords[i])
         {
            var errx = predictedCoords[i].x - result.actualCoords[i].x;
            var erry = predictedCoords[i].y - result.actualCoords[i].y;
            numFitted++;
            stddev2 += errx * errx + erry * erry;
            result.errors2[i]=errx * errx + erry * erry;
         }
      }
      stddev2/=numFitted;

      // Remove stars with too high error (>3*sigma)
      var sum = 0;
      result.numValid = 0;
      result.numRejected = 0;
      console.writeln(format("Error StdDev=%.2f pixels", Math.sqrt(stddev2)));
      var tolerance2=Math.min(stddev2*3* 3,25);
      console.writeln(format("Tolerance for rejecting stars: %.2f pixels", Math.sqrt(tolerance2)));
      for (var i = 0; i < predictedCoords.length; i++)
      {
         if (predictedCoords[i] && result.actualCoords[i])
         {
            if (result.errors2[i] > tolerance2)
            {
               result.actualCoords[i] = null;
               result.numRejected++;
            }
            else
            {
               sum += result.errors2[i];
               result.numValid++;
            }
         }
      }
      if (result.numValid > 0)
         result.rms = Math.sqrt(sum / result.numValid);

      console.writeln("Valid stars: ", result.numValid);
      console.writeln("Rejected stars: ", result.numRejected);

      return result;
   }

   this.GetDistortion = function (metadata)
   {
      var incx = (metadata.width - 0.01) / Math.round(metadata.width / 20);
      var incy = (metadata.height - 0.01) / Math.round(metadata.height / 20);
      var pD = []; // DistortedCoords
      var pL = []; // LinealCoords
      var ref_G_I_lineal = metadata.ref_I_G_lineal.inverse();
      for (var y = 0; y <= metadata.height; y += incy)
         for (var x = 0; x <= metadata.width; x += incx)
         {
            var p = new Point(x, y);
            var pG = metadata.ref_I_G.Apply(p);
            var pLineal = ref_G_I_lineal.Apply(pG);
            pD.push(p);
            pL.push(pLineal);
         }
      console.writeln("nump: ", pD.length);
      var distortion = {
         ref_D_L:MultipleLinearRegression(metadata.ref_I_G.polDegree, pD, pL),
         ref_L_D:MultipleLinearRegression(metadata.ref_I_G.polDegree, pL, pD)
      };

      console.writeln(distortion.ref_D_L.toString());
      console.writeln(distortion.ref_L_D.toString());
      return distortion;
   }

   this.DoIterationMLR = function(polDegree, stars)
   {
      console.writeln("Starting MLR iteration. Polynomial degree ", polDegree);

      // There should be at least GetNumCoef(polDegree) samples. However, for achieving
      // enough precision the script requires twice the number of samples.
      if(stars.numValid<ReferNPolyn.prototype.GetNumCoef(polDegree)*2)
         throw "There are not enough stars for using a polyonomial of degree "+ polDegree.toString()+
            format(". There should be at least %d stars", ReferNPolyn.prototype.GetNumCoef(polDegree)*2);

      // Find referentiation matrices
      var newMetadata = this.metadata.Clone();
      newMetadata.projection = stars.projection;
      newMetadata.ref_I_G = MultipleLinearRegression(polDegree, stars.actualCoords, stars.coordsG);
      if (polDegree == 1) // When the degree is 1 the inverse referentiation can be calculated as the inverse matrix
      {
         newMetadata.ref_I_G_lineal = newMetadata.ref_I_G.ToLinealMatrix();
         newMetadata.ref_G_I = ReferNPolyn.prototype.FromLinealMatrix(newMetadata.ref_I_G_lineal.inverse());
      }
      else
      {
         newMetadata.ref_I_G_lineal = MultipleLinearRegression(1, stars.actualCoords, stars.coordsG).ToLinealMatrix();
         newMetadata.ref_G_I = MultipleLinearRegression(polDegree, stars.coordsG, stars.actualCoords);
      }


      // Find the celestial coordinates (RD) of the center of the original image
      // First transform from I to G and then unprojects the gnomonic coords (G) to celestial (RD)
      var centerI = new Point( this.metadata.width/2, this.metadata.height/2 );
      var centerG = newMetadata.ref_I_G.Apply( centerI );
      var centerRD = newMetadata.projection.Inverse( centerG );
      while(centerRD.x<0)
         centerRD.x += 360;
      while(centerRD.x>360)
         centerRD.x -= 360;
      newMetadata.ra = centerRD.x;
      newMetadata.dec = centerRD.y;
      var ref = newMetadata.ref_I_G_lineal;
      var resx = Math.sqrt(ref.at(0, 0) * ref.at(0, 0) + ref.at(0, 1) * ref.at(0, 1));
      var resy = Math.sqrt(ref.at(1, 0) * ref.at(1, 0) + ref.at(1, 1) * ref.at(1, 1));
      newMetadata.resolution = (resx + resy) / 2;
      newMetadata.focal = newMetadata.FocalFromResolution( newMetadata.resolution );
      newMetadata.useFocal = false;

      return newMetadata;
   }

   this.CalculateMetadataDelta = function(metadata1, metadata2)
   {
      // Calculate the difference between the last two iterations using the displacement of the center and one corner
      var cornerI = new Point(0,0);
      var cornerRD2 = metadata2.Convert_I_RD(cornerI);
      var cornerRD1 = metadata1.ref_I_G ? metadata1.Convert_I_RD(cornerI) : cornerRD2;
      var delta1 = Math.sqrt(Math.pow((cornerRD1.x - cornerRD2.x) * Math.cos(cornerRD2.y * Math.PI / 180), 2) +
         Math.pow((cornerRD1.y - cornerRD2.y), 2)) * 3600;
      var delta2 = Math.sqrt(Math.pow((metadata2.ra - metadata1.ra) * Math.cos(metadata2.dec * Math.PI / 180), 2) +
         Math.pow(metadata2.dec - metadata1.dec, 2)) * 3600;
      return Math.max(delta1, delta2);
   }

   this.SolveImage = function( )
   {
      console.show();
      console.abortEnabled = true;

      console.writeln("Seed parameters for the plate solving:");
      console.writeln("   Image coordinates: RA=",
         DMSangle.FromAngle(this.metadata.ra * 24 / 360).ToString(true), ", Dec=",
         DMSangle.FromAngle(this.metadata.dec).ToString());
      console.writeln("   Resolution: ", this.metadata.resolution * 3600);

      var clipRect = null;
      if(this.activeWindow.numberOfPreviews>0)
      {
         clipRect = this.activeWindow.previewRect(this.activeWindow.previews[0]);
         console.writeln("ClipRect: ",clipRect);
      }

      this.solverCfg.templateSizeFactor = 1.5;
      var iteration = 1;
      var stars = null;
      var finish = false;
      var deltaTolerance = this.metadata.resolution*3600 * 0.05;

      var iterationDegree=1;

      //FIRST ITERATION
      if(this.solverCfg.onlyOptimize)
      {
         stars = this.DetectStars(this.activeWindow, this.metadata, clipRect);
         if(this.metadata.ref_I_G.polDegree)
            iterationDegree = this.metadata.ref_I_G.polDegree;

         // Show iteration info
         console.writeln( "<end><cbr><br>*****" );
         console.writeln( "Original coordinates:" );
         console.writeln(         "Image center ...... RA: ", DMSangle.FromAngle( this.metadata.ra*24/360 ).ToString( true ),
            "  Dec: ", DMSangle.FromAngle( this.metadata.dec ).ToString() );
         console.writeln( format( "Resolution ........ %.2f arcsec/pix", this.metadata.resolution*3600 ) );
         console.writeln( format( "RMS ............... %.4f pix (%d stars)", stars.rms, stars.numValid ) );
         console.writeln( "*****" );
      }
      else
      {
         var result=null;
         if(this.solverCfg.distortionTemplate)
         {
            var itresult=this.DoIterationDistortion();
            if(itresult)
            {
               result=itresult[0];
               stars=itresult[1];
               iterationDegree = result.ref_I_G.polDegree;
            }
            //finish=true;
         }else{
            result=this.DoIterationSA(this.activeWindow);
            if(result)
               stars = this.DetectStars(this.activeWindow, result, clipRect);
         }
         if(result==null){
               console.writeln( "*** The image could not be solved." );
               console.writeln( "This is usually because the initial parameters are too far from the real metadata of the image" );
               return false;
         }

         var delta = this.CalculateMetadataDelta(this.metadata,result);

         // Show iteration info
         console.writeln( "<end><cbr><br>*****" );
         console.writeln( format( "Iteration 1, delta = %.3f arcsec (%.2f pixels)", delta, delta/(result.resolution*3600) ) );
         console.writeln(         "Image center ...... RA: ", DMSangle.FromAngle( result.ra*24/360 ).ToString( true ),
            "  Dec: ", DMSangle.FromAngle( result.dec ).ToString() );
         console.writeln( format( "Resolution ........ %.2f arcsec/pix", result.resolution*3600 ) );
         console.writeln( format( "RMS ............... %.4f pix (%d stars)", stars.rms, stars.numValid ) );
         console.writeln( "*****" );
         this.metadata = result;
         iteration++;
         finish=true;
      }

      while ( !finish )
      {
         console.abortEnabled = true;
         iterationDegree = Math.min(iterationDegree,this.solverCfg.polyDegree);
         var result=this.DoIterationMLR(iterationDegree++, stars);
         if(result==null)
         {
            console.writeln( " *** The image could not be fully solved. The image is tagged using the last good solution" );
            break;
         }

         stars = this.DetectStars(this.activeWindow, result, clipRect);
         if(clipRect!=null)
         {
            clipRect = new Rect(clipRect.x0-clipRect.width*0.1,clipRect.y0-clipRect.height*0.1,
                                clipRect.x1+clipRect.width*0.1,clipRect.y1+clipRect.height*0.1);
            clipRect.intersect(0,0,this.metadata.width,this.metadata.height);
            console.writeln("ClipRect: ",clipRect);
            if(clipRect.width == this.metadata.width && clipRect.height == this.metadata.height)
               clipRect=null;
         }

         // Calculate the difference between the last two iterations using the displacement of the center and one corner
         var delta = this.CalculateMetadataDelta(this.metadata,result);

         // Show iteration info
         console.writeln( "<end><cbr><br>*****" );
         console.writeln( format( "Iteration %d, delta = %.3f arcsec (%.2f pixels)", iteration, delta, delta/(result.resolution*3600) ) );
         console.writeln(         "Image center ...... RA: ", DMSangle.FromAngle( result.ra*24/360 ).ToString( true ),
                                                   "  Dec: ", DMSangle.FromAngle( result.dec ).ToString() );
         console.writeln( format( "Resolution ........ %.2f arcsec/pix", result.resolution*3600 ) );
         console.writeln( format( "RMS ............... %.4f pix (%d stars)", stars.rms, stars.numValid ) );
         console.writeln( "*****" );
         this.metadata = result;

         // Finish condition
         finish = this.metadata.ref_I_G.polDegree==this.solverCfg.polyDegree &&
                  clipRect == null &&
                  (delta<deltaTolerance || iteration>=this.solverCfg.maxIterations);

         iteration++;
         this.solverCfg.templateSizeFactor = 1;
         this.solverCfg.showStars = false;

         gc(true);
      }

      // Set FITS keywords
      if ( this.solverCfg.updateKeywords || this.solverCfg.writeWCS )
      {
         this.activeWindow.mainView.beginProcess( UndoFlag_Keywords );
         var keywords = this.activeWindow.keywords;

         if ( this.solverCfg.updateKeywords )
            this.metadata.UpdateBasicKeywords(keywords);

         if ( this.solverCfg.writeWCS )
         {
            this.metadata.UpdateWCSKeywords(keywords);
            this.metadata.UpdateReferKeywords(keywords);
         }

         this.activeWindow.keywords = keywords;
         this.activeWindow.mainView.endProcess();
      }

      // Debug windows
      if(this.solverCfg.showDistortion && this.metadata.ref_I_G.polDegree!=null && this.metadata.ref_I_G.polDegree>1)
         this.DrawDistortions(this.metadata);

      if(this.solverCfg.generateErrorImg)
         this.DrawErrors(this.metadata, stars);

      return true;
   }
}

function CheckVersion( major, minor, release )
{
   if( major == __PI_MAJOR__ )
   {
      if( minor == __PI_MINOR__ )
         return release <= __PI_RELEASE__;
      else
         return minor < __PI_MINOR__;
   }
   else
      return major < __PI_MAJOR__;
}

#ifndef USE_SOLVER_LIBRARY
function main()
{
   //console.hide();
   if( !CheckVersion( 1, 8, 0 ) )
   {
      new MessageBox( "This script requires at least the version 1.8.0 of PixInsight", TITLE, StdIcon_Error, StdButton_Ok ).execute();
      return;
   }

   var solver = new ImageSolver();

   if( Parameters.isViewTarget )
   {
      solver.Init( Parameters.targetView.window );
   }
   else
   {
      do {
         solver.Init( ImageWindow.activeWindow, false );
         var dialog = new ImageSolverDialog( solver.solverCfg, solver.metadata );
         var res = dialog.execute();
         if ( !res ){
            if( dialog.resetRequest ){
               solver = new ImageSolver();
            }else
               return;
         }
      } while( !res );
   }

   if ( solver.error )
   {
      console.writeln( solver.error );
      return;
   }

   solver.solverCfg.SaveSettings();
   solver.metadata.SaveSettings();

   if( solver.SolveImage() )
   {
      solver.metadata.SaveSettings();

      // Print result
      console.writeln( "<end><cbr><br>Image Plate Solver script version ", SOLVERVERSION );
      console.writeln( "===============================================================================" );
      solver.metadata.Print();
      console.writeln( "===============================================================================" );
   }
}

main();
#endif

#undef USE_SOLVER_LIBRARY
